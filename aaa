#include "so_stdio.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>


#define BUFFSIZE 4096

struct _so_file
{
  int file_descriptor;
  char buffer[BUFFSIZE];
  int last_op_done;          //0-Default 1-Read 2-Write
  int buffer_cursor;
  int file_cursor;
  int error;
  int eof;     //1-not reached,0 for reached
};
typedef struct _so_file SO_FILE;

SO_FILE *so_fopen(const char *pathname, const char *mode){
    
  
   
    int fd=-1;
    if(0==strcmp(mode,"r")){
        fd=open(pathname,O_RDONLY);
       
    }
    else if (0==strcmp(mode,"r+"))
    {
           fd=open(pathname,O_RDWR);
      
    }
    else if (0==strcmp(mode,"w"))
    {
           fd=open(pathname,O_WRONLY|O_CREAT|O_TRUNC,0644);
       
    }
    else if (0==strcmp(mode,"w+"))
    {
           fd=open(pathname,O_RDWR|O_CREAT|O_TRUNC,0644);
       
    }
    else if (0==strcmp(mode,"a"))
    {
           fd=open(pathname,O_WRONLY|O_APPEND|O_CREAT,0644);
       
    }
    else if (0==strcmp(mode,"a+"))
    {
           fd=open(pathname,O_RDWR|O_APPEND|O_CREAT,0644);
        
    }
    else{
        
        return NULL;
    }
   if(fd<0){
            
            return NULL;
        }
        else{
             SO_FILE* stream=malloc(sizeof(SO_FILE));
             if(stream==NULL){
              return NULL;
             }
             stream->file_descriptor=fd;
            memset(stream->buffer,0,BUFFSIZE);
            stream->buffer_cursor=0;
            stream->last_op_done=0;
            stream->error=0;
            stream->file_cursor=0;
            stream->eof=1;
            return stream;
        }
    
     
    return NULL;
};

int so_fclose(SO_FILE *stream){
if(close(stream->file_descriptor)<0){
    stream->error=SO_EOF;
    return SO_EOF;
}
else{
    free(stream);
    return 0;
}
};

int so_fflush(SO_FILE* stream){
    int i=0;
    printf("%d",stream->buffer_cursor);
    while(i<stream->buffer_cursor){
        int x=write(stream->file_descriptor,stream->buffer+i,stream->buffer_cursor-i);
        if(x<0){
            stream->error=SO_EOF;
            return SO_EOF;
        };
        i+=x;
    }

    stream->last_op_done=0;
    return 0;

};

int so_fgetc(SO_FILE *stream){
    if(NULL==stream){
        printf("Here stream is null!");
        stream->error=SO_EOF;
        return SO_EOF;
    }
    if(stream->eof==0&&stream->buffer_cursor==BUFFSIZE){
        printf("Here 1 eof is 0!");
        stream->error=SO_EOF;
        return SO_EOF;
    }
    if(stream->last_op_done==2){
         printf("Problem last op done is WRITE so nothing happends!");
        memset (stream->buffer,0,BUFFSIZE);
        stream->buffer_cursor=0;
        stream->last_op_done=0;
    }
    if(stream->buffer_cursor<BUFFSIZE&&stream->last_op_done==1){
        stream->buffer_cursor++;
        if(stream->buffer[stream->buffer_cursor]==0){
            printf("Reading nulls from buffer!");
            stream->error=SO_EOF;
            return SO_EOF;
        }
        return stream->buffer[stream->buffer_cursor];
    }
    
    stream->eof=read(stream->file_descriptor,stream->buffer,BUFFSIZE);
    stream->last_op_done=1;
    stream->buffer_cursor=0;
    stream->eof=0;
    return stream->buffer[stream->buffer_cursor];
};

int so_fileno(SO_FILE *stream){
return stream->file_descriptor;
};

int so_ferror(SO_FILE *stream){
return stream->error;
};

int so_feof(SO_FILE *stream){
return stream->eof;
};

int so_fputc(int c, SO_FILE *stream){
    if(NULL==stream){
        printf("Blocked at nullstream");
        stream->error=SO_EOF;
        return SO_EOF;
    }
    if(stream->buffer_cursor>BUFFSIZE){
        printf("Blocked at  size of curosr ");
        stream->error=SO_EOF;
        return SO_EOF;
    }
    if(stream->last_op_done==1){
        memset (stream->buffer,0,BUFFSIZE);
        stream->buffer_cursor=0;
        stream->last_op_done=0;
    }
    if(stream->buffer_cursor==BUFFSIZE){
        so_fflush(stream);
        //flush
    }
    stream->buffer[stream->buffer_cursor]=c;
    stream->buffer_cursor++;
    stream->last_op_done=2;
    return stream->buffer[stream->buffer_cursor-1];
}

int so_fseek(SO_FILE *stream, long offset, int whence){
    if(stream->last_op_done==2){
        so_fflush(stream);
    }
    else if (stream->last_op_done==1)
    {
        memset (stream->buffer,0,BUFFSIZE);
        stream->buffer_cursor=0;
        stream->last_op_done=0;
    }

    stream->file_cursor=lseek(stream->file_descriptor,offset,whence);

    if(stream->file_cursor<0){
        stream->error=SO_EOF;
        printf("Problem at SO_EOF");
        return SO_EOF;
    }
    return stream->file_cursor;
};

long so_ftell(SO_FILE *stream){
    if(NULL==stream){
        stream->error=SO_EOF;
        return SO_EOF;
    }
   return stream->file_cursor;
};

size_t so_fread(void *ptr, size_t size, size_t nmemb, SO_FILE *stream){
    if(stream==NULL){
        return SO_EOF;
    }
    int count=0;
    stream->last_op_done=1;
    while(size*nmemb>stream->buffer_cursor){
        //char *word=(char*)malloc(sizeof(char));
        int error=so_fgetc(stream);
        if(error<0){
            return SO_EOF;
        }
        memcpy(ptr+count,&stream->buffer[count],size);
        count++;
    }
    return count;
};

size_t so_fwrite(const void *ptr, size_t size, size_t nmemb, SO_FILE *stream){


    return 0;
};
